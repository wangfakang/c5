{
  "name": "C5",
  "tagline": "simulation of the gdb backtrace",
  "body": "如何通过函数的地址获取到函数的名字\r\n====\r\n\r\n```c\r\n#include <stdio.h>\r\n#include <execinfo.h>\r\n \r\nvoid my_name_is_fucking(void) {\r\n    printf(\"fucking\\n\");\r\n}\r\n \r\nint main(int argc, char *argv[]) {\r\n    void    *funptr = &my_name_is_fucking;\r\n \r\n    backtrace_symbols_fd(&funptr, 1, 1);\r\n \r\n    return 0;\r\n}\r\n```\r\n\r\n通过gcc编译的时候增加`-rdynamic`编译选项，该编译选项的含义是：使得程序中的共享库的全局符号可用\r\n\r\n\r\n\r\n如何打印出一个程序的函数调用链路\r\n====\r\n\r\n```c\r\n#include <stdio.h>\r\n\r\n\r\n#define debug_print(fmt, args...) do { \\\r\n            fprintf(stderr, fmt, ##args); \\\r\n        }while(0)\r\n\r\n\r\nvoid __cyg_profile_func_exit(void* callee, void* callsite) __attribute__((no_instrument_function));\r\nvoid __cyg_profile_func_enter(void* callee, void* callsite) __attribute__((no_instrument_function));\r\n\r\n\r\nvoid __cyg_profile_func_enter(void* callee, void* callsite) {\r\n    debug_print(\"Entering %p in %p\\n\", callee, callsite);\r\n}\r\n\r\n\r\nvoid __cyg_profile_func_exit(void* callee, void* callsite) {\r\n    debug_print(\"Exiting %p in %p\\n\", callee, callsite);\r\n}\r\n\r\n\r\nvoid foo4() {\r\n    printf(\"foo()\\n\");\r\n}\r\n\r\n\r\nvoid foo3() {\r\n    foo4();\r\n}\r\n\r\n\r\nvoid foo2() {\r\n    foo3();\r\n}\r\n\r\n\r\nvoid foo1() {\r\n    foo2();\r\n}\r\n\r\n\r\nint main() {\r\n    foo1();\r\n    return 0;\r\n}\r\n```\r\n\r\n\r\n打印程序的调用链路，主要是利用到`__attribute__`可以用来设置 [Function-Attributes](http://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Function-Attributes.html)函数属性\r\n我们使用的是：`no_instrument_function`这个函数属性，在gcc编译的时候加上：`-finstrument-functions`编译选项就会在每一个用户自定义函数中添加下面两个函数调用:\r\n\r\n```c\r\nvoid __cyg_profile_func_enter(void *this, void *callsite);\r\nvoid __cyg_profile_func_exit(void *this, void *callsite);\r\n```  \r\n\r\n这两个函数我们用户可以自己实现，其中`this`指针指向当前函数的地址，`callsite`是指向上一级调用函数的地址\r\n\r\n\r\n\r\n\r\n\r\n\r\n综合前面两个问题就可以打印出一个完整的程序调用堆栈信息   \r\n=====\r\n\r\n`trace_func.c`\r\n\r\n```c\r\n\r\n#include <stdio.h>\r\n#include <malloc.h>\r\n#include <execinfo.h>\r\n\r\n\r\nvoid __cyg_profile_func_exit(void* callee, void* callsite) __attribute__((no_instrument_function));\r\nvoid __cyg_profile_func_enter(void* callee, void* callsite) __attribute__((no_instrument_function));\r\n\r\n\r\nvoid __cyg_profile_func_enter(void* callee, void* callsite) {\r\n    void    *funptr = callee;\r\n    char **p = backtrace_symbols(&funptr, 1);\r\n    printf(\"Entering: %s\\n\", *p);\r\n    free(p);\r\n}\r\n\r\n\r\nvoid __cyg_profile_func_exit(void* callee, void* callsite) {\r\n    void    *funptr = callee;\r\n    char **p = backtrace_symbols(&funptr, 1);\r\n    printf(\"Exiting: %s\\n\", *p);\r\n    free(p);\r\n}\r\n\r\n\r\nvoid foo4() {\r\n    printf(\"foo()\\n\");\r\n}\r\n\r\n\r\nvoid foo3() {\r\n    foo4();\r\n}\r\n\r\n\r\nvoid foo2() {\r\n    foo3();\r\n}\r\n\r\n\r\nvoid foo1() {\r\n    foo2();\r\n}\r\n\r\n\r\nint main() {\r\n    foo1();\r\n    return 0;\r\n}\r\n```\r\n\r\n`gcc trace_func.c -rdynamic -finstrument-functions   `\r\n\r\n\r\n最终就会输出：\r\n\r\n```\r\nEntering: ./a.out(main+0) [0x400a32]\r\nEntering: ./a.out(foo1+0) [0x400a06]\r\nEntering: ./a.out(foo2+0) [0x4009da]\r\nEntering: ./a.out(foo3+0) [0x4009ae]\r\nEntering: ./a.out(foo4+0) [0x400982]\r\nfoo()\r\nExiting: ./a.out(foo4+0) [0x400982]\r\nExiting: ./a.out(foo3+0) [0x4009ae]\r\nExiting: ./a.out(foo2+0) [0x4009da]\r\nExiting: ./a.out(foo1+0) [0x400a06]\r\nExiting: ./a.out(main+0) [0x400a32]\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n欢迎一起交流学习 \r\n====\r\n \r\n在使用中有任何问题，欢迎反馈给我，可以用以下联系方式跟我交流\r\n\r\n* 邮件(1031379296#qq.com, 把#换成@)\r\n* QQ: 1031379296\r\n* weibo: [@王发康](http://weibo.com/u/2786211992/home)\r\n\r\n\r\nThx\r\n====\r\n\r\n* chunshengsterATgmail.com\r\n\r\n\r\nAuthor\r\n====\r\n* Linux\\nginx\\golang\\c\\c++爱好者\r\n* 欢迎一起交流  一起学习# \r\n* Others say good and Others good\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}